# -*- coding: utf-8 -*-
"""Ej2_PDI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/163ARhUDqBqEWpgNXEQQf5-4MbGc7BHUu
"""

import cv2
import numpy as np
#from google.colab.patches import cv2_imshow

def limpiar_ruido(imagen_binaria, distancia_umbral):
    # Componentes conectadas
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(imagen_binaria, connectivity=4)

    # Eliminar ruido
    for i in range(1, num_labels):
        # Calcular el centroide de la componente actual
        centroide_actual = centroids[i]

        # Calcular la distancia a otras componentes
        distancias = np.linalg.norm(centroide_actual - centroids, axis=1)

        # Excluir la componente actual (distancia a sí misma)
        distancias[i] = np.inf

        # Encontrar índice de la componente más cercana
        mindis = min(distancias)

        # Eliminar la componente si la distancia es mayor que el umbral
        if mindis > distancia_umbral:
            imagen_binaria[labels == i] = 0

    return imagen_binaria
for i in range(1,13):
  if i < 10:
    ruta = 'img0' + str(i) + '.png'
  else:
    ruta = 'img' + str(i) + '.png'
  imagen_original = cv2.imread(ruta)

  # 2. Convertir a escala de grises
  imagen_gris = cv2.cvtColor(imagen_original, cv2.COLOR_BGR2GRAY)

  # 3. Umbralado
  imagen_umbralizada = cv2.adaptiveThreshold(imagen_gris, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 9, -10) #9 y -10 anda en 10/12
  #cv2_imshow(imagen_umbralizada)

  # 4. Componentes conectados
  num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(imagen_umbralizada, connectivity=4)

  # 5. Filtrar por área y relacion de aspecto
  area_minima = 25
  area_maxima = 90
  aspect_ratio_min = 0.4
  aspect_ratio_max = 0.7

  area_filtrada = np.zeros_like(imagen_umbralizada)

  for i in range(1, num_labels):
      aspect_ratio = stats[i, cv2.CC_STAT_WIDTH] / stats[i, cv2.CC_STAT_HEIGHT]
      if (
          area_minima < stats[i][4] and stats[i][4] < area_maxima
          and aspect_ratio_min < aspect_ratio and aspect_ratio < aspect_ratio_max
      ):
          area_filtrada[labels == i] = imagen_umbralizada[labels == i]

  #cv2_imshow(area_filtrada)

  # 7. Eliminar ruido usando la distancia entre componentes conectados
  distancia_umbral = 15
  area_limpiada = limpiar_ruido(area_filtrada.copy(), distancia_umbral)

  se = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 1))
  area_limpiada_open = cv2.morphologyEx(area_limpiada, cv2.MORPH_OPEN, se)
  imagen_final = cv2.morphologyEx(area_limpiada_open, cv2.MORPH_CLOSE, se)
  w, h = imagen_final.shape

  # Mostrar resultados
  #cv2_imshow(imagen_original)
  cv2.imshow(imagen_final[80:w-50,170:h-50])
  #cv2.waitKey(0)
  #cv2.destroyAllWindows()
  print('----------------------------------------------')

  num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(imagen_final[80:w-50,170:h-50], connectivity=4)
  for label in range(1, num_labels):  # Comienza desde 1 para excluir el fondo
    component_mask = (labels == label).astype(np.uint8) * 255
    cv2.imshow(component_mask)
    print('----------------------------------------------')

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# 1. Abrir la imagen original
imagen_original = cv2.imread('img12.png')

# 2. Convertir a escala de grises
imagen_gris = cv2.cvtColor(imagen_original, cv2.COLOR_BGR2GRAY)

# 3. Umbralado
imagen_umbralizada = cv2.adaptiveThreshold(imagen_gris, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 5, 0)
cv2_imshow(imagen_umbralizada)
# 4. Componentes conectados
num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(imagen_umbralizada, connectivity=4)

# 5. Filtrar por área y relacion de aspecto
area_minima = 20
area_maxima = 100
aspect_ratio_min = 0.3
aspect_ratio_max = 1

area_filtrada = np.zeros_like(imagen_umbralizada)

for i in range(1, num_labels):
    aspect_ratio = stats[i, cv2.CC_STAT_WIDTH] / stats[i, cv2.CC_STAT_HEIGHT]
    if (
        area_minima < stats[i][4] < area_maxima
        and aspect_ratio_min < aspect_ratio and aspect_ratio < aspect_ratio_max
    ):
        area_filtrada[labels == i] = imagen_umbralizada[labels == i]

cv2_imshow(area_filtrada)
# 6. Filtrado por relación de aspecto
aspect_ratio_min = 1.5  # ajusta este valor según tus necesidades
aspect_ratio_max = 4  # ajusta este valor según tus necesidades
imagen_aspecto_filtrado = np.zeros_like(imagen_umbralizada)
for i in range(1, num_labels):
    aspect_ratio = stats[i, cv2.CC_STAT_WIDTH] / stats[i, cv2.CC_STAT_HEIGHT]
    if aspect_ratio_min < aspect_ratio and aspect_ratio < aspect_ratio_max:
        imagen_aspecto_filtrado[labels == i] = 255

# 7. Eliminar ruido usando la distancia entre componentes conectados
distancia_minima = 30  # ajusta este valor según tus necesidades
kernel = np.ones((distancia_minima, distancia_minima), np.uint8)
imagen_limpia = cv2.morphologyEx(imagen_aspecto_filtrado, cv2.MORPH_CLOSE, kernel)

# Mostrar resultados
cv2_imshow(imagen_original)
cv2_imshow(imagen_limpia)
cv2.waitKey(0)
cv2.destroyAllWindows()